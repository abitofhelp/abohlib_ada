--   =============================================================================
--   Test_Contracts - Contract Validation Unit Tests Implementation
--   =============================================================================

pragma Ada_2022;

with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;
with ULID;
with Abohlib.Core.Domain.Value_Objects.File_Path;
with Abohlib.Core.Domain.Utilities.ULID_Helpers;
with Abohlib.Core.Domain.Errors;

package body Test_Contracts is

   use Abohlib.Core.Domain.Value_Objects.File_Path;
   use Abohlib.Core.Domain.Utilities.ULID_Helpers;
   use Abohlib.Core.Domain.Errors;

--   ==========================================================================
--   File Path Contract Tests
--   ==========================================================================

   function Test_File_Path_Creation_Contracts return Void_Result.Result is
   begin
--  Test contract validation works by verifying File_Path creation succeeds for valid paths
--  Note: Type_Invariant ensures Is_Valid is always true for successfully created paths
      declare
         Valid_Path : constant File_Path := Create ("test.txt", Input);
      begin
--  If we reach here, the contract allowed the creation
         if Category (Valid_Path) /= Input then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Path category should be preserved"),
               Details     => To_Unbounded_String ("Expected Input, got: " & Category (Valid_Path)'Image),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_File_Path_Creation_Contracts")
            ));
         end if;
      end;

--  Test different path category
      declare
         Output_Path : constant File_Path := Create ("output.log", Output);
      begin
         if Category (Output_Path) /= Output then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Path category should be preserved"),
               Details     => To_Unbounded_String ("Expected Output, got: " & Category (Output_Path)'Image),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_File_Path_Creation_Contracts")
            ));
         end if;
      end;

      return Void_Result.Ok (True);
   end Test_File_Path_Creation_Contracts;

   function Test_File_Path_Validation_Contracts return Void_Result.Result is
   begin
--  Test file name extraction contract with simple path
      declare
         Test_Path : constant File_Path := Create ("document.pdf", Input);
         Name : constant String := File_Name (Test_Path);
      begin
         if Name'Length = 0 then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("File name should not be empty"),
               Details     => To_Unbounded_String ("Path: " & Value (Test_Path)),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_File_Path_Validation_Contracts")
            ));
         end if;

         if Name'Length > Value (Test_Path)'Length then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("File name should not be longer than full path"),
               Details     => To_Unbounded_String ("Name length: " & Name'Length'Image &
                                                  ", Path length: " & Value (Test_Path)'Length'Image),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_File_Path_Validation_Contracts")
            ));
         end if;

         if Contains_Path_Separator (Name) then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("File name should not contain path separators"),
               Details     => To_Unbounded_String ("Name: " & Name),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_File_Path_Validation_Contracts")
            ));
         end if;
      end;

      return Void_Result.Ok (True);
   end Test_File_Path_Validation_Contracts;

   function Test_File_Path_Manipulation_Contracts return Void_Result.Result is
   begin
--  Test extension extraction contracts with simple path
      declare
         Test_Path : constant File_Path := Create ("document.pdf", Input);
         Ext : constant String := Extension (Test_Path);
      begin
         if Ext'Length > 255 then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Extension should not exceed 255 characters"),
               Details     => To_Unbounded_String ("Extension length: " & Ext'Length'Image),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_File_Path_Manipulation_Contracts")
            ));
         end if;

         if Ext'Length > 0 and then Ext (Ext'First) /= '.' then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Non-empty extension should start with dot"),
               Details     => To_Unbounded_String ("Extension: " & Ext),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_File_Path_Manipulation_Contracts")
            ));
         end if;
      end;

      return Void_Result.Ok (True);
   end Test_File_Path_Manipulation_Contracts;

--   ==========================================================================
--   ULID Contract Tests
--   ==========================================================================

   function Test_ULID_String_Validation_Contracts return Void_Result.Result is
   begin
--  Test empty string validation
      if Is_Valid_ULID_String ("") then
         return Void_Result.Err (Test_Error'(
            Kind        => Assertion_Failed,
            Message     => To_Unbounded_String ("Empty string should not be valid ULID"),
            Details     => Null_Unbounded_String,
            Line_Number => 0,
            Test_Name   => To_Unbounded_String ("Test_ULID_String_Validation_Contracts")
         ));
      end if;

--  Test wrong length validation
      if Is_Valid_ULID_String ("0123456789") then
         return Void_Result.Err (Test_Error'(
            Kind        => Assertion_Failed,
            Message     => To_Unbounded_String ("Short string should not be valid ULID"),
            Details     => Null_Unbounded_String,
            Line_Number => 0,
            Test_Name   => To_Unbounded_String ("Test_ULID_String_Validation_Contracts")
         ));
      end if;

--  Test valid ULID string
      declare
         Valid_ULID : constant String := New_ULID_String;
      begin
         if not Is_Valid_ULID_String (Valid_ULID) then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Generated ULID string should be valid"),
               Details     => To_Unbounded_String ("ULID: " & Valid_ULID),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_ULID_String_Validation_Contracts")
            ));
         end if;

         if Valid_ULID'Length /= ULID_String_Length then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Generated ULID should have correct length"),
               Details     => To_Unbounded_String ("Expected: " & ULID_String_Length'Image &
                                                  ", Got: " & Valid_ULID'Length'Image),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_ULID_String_Validation_Contracts")
            ));
         end if;
      end;

      return Void_Result.Ok (True);
   end Test_ULID_String_Validation_Contracts;

   function Test_ULID_Generation_Contracts return Void_Result.Result is
   begin
--  Test ULID generation produces non-null values
      declare
         Test_ULID : constant ULID.ULID_Number := New_ULID;
      begin
         if Is_Null (Test_ULID) then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Generated ULID should not be null"),
               Details     => To_Unbounded_String ("ULID value: " & Test_ULID'Image),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_ULID_Generation_Contracts")
            ));
         end if;
      end;

--  Test string generation contracts
      declare
         Test_String : constant String := New_ULID_String;
      begin
         if Test_String'Length /= ULID_String_Length then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Generated ULID string should have correct length"),
               Details     => To_Unbounded_String ("Expected: " & ULID_String_Length'Image &
                                                  ", Got: " & Test_String'Length'Image),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_ULID_Generation_Contracts")
            ));
         end if;

         if not Is_Valid_ULID_String (Test_String) then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Generated ULID string should pass validation"),
               Details     => To_Unbounded_String ("String: " & Test_String),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_ULID_Generation_Contracts")
            ));
         end if;
      end;

      return Void_Result.Ok (True);
   end Test_ULID_Generation_Contracts;

   function Test_ULID_Protected_Generator_Contracts return Void_Result.Result is
   begin
--  Test protected generator produces non-null ULIDs
      declare
         Test_ULID : ULID.ULID_Number;
      begin
         ULID_Generator.Generate (Test_ULID);

         if Is_Null (Test_ULID) then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Protected generator should produce non-null ULID"),
               Details     => To_Unbounded_String ("ULID value: " & Test_ULID'Image),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_ULID_Protected_Generator_Contracts")
            ));
         end if;
      end;

--  Test protected string generation
      declare
         Buffer : String (1 .. ULID_String_Length + 10); -- Extra space to test boundary
         Last : Natural;
      begin
         ULID_Generator.Generate_String (Buffer, Last);

         if Last /= Buffer'First + ULID_String_Length - 1 then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Protected generator should set correct Last index"),
               Details     => To_Unbounded_String ("Expected: " &
                                                  Natural'Image (Buffer'First + ULID_String_Length - 1) &
                                                  ", Got: " & Last'Image),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_ULID_Protected_Generator_Contracts")
            ));
         end if;

         if not Is_Valid_ULID_String (Buffer (Buffer'First .. Last)) then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Protected generator should produce valid ULID string"),
               Details     => To_Unbounded_String ("String: " & Buffer (Buffer'First .. Last)),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_ULID_Protected_Generator_Contracts")
            ));
         end if;
      end;

      return Void_Result.Ok (True);
   end Test_ULID_Protected_Generator_Contracts;

--   ==========================================================================
--   Error Construction Contract Tests
--   ==========================================================================

   function Test_Error_Constructor_Length_Limits return Void_Result.Result is
   begin
--  Test validation error with maximum length strings
      declare
         Max_Field : constant String (1 .. Max_Field_Name_Length) := (others => 'A');
         Max_Message : constant String (1 .. Max_Error_Message_Length) := (others => 'B');
         Max_Recovery : constant String (1 .. Max_Recovery_Suggestion_Length) := (others => 'C');
         Max_Context : constant String (1 .. Max_Error_Context_Length) := (others => 'D');
         Max_Correlation : constant String (1 .. Max_Correlation_ID_Length) := (others => 'E');

         Error : constant Validation_Error_Type := Make_Validation_Error (
            Kind          => Required_Field_Missing,
            Field_Name    => Max_Field,
            Invalid_Value => Max_Message,
            Message       => Max_Message,
            Recovery      => Max_Recovery,
            Context       => Max_Context,
            Correlation   => Max_Correlation
         );
      begin
--  If we reach here, the contract allowed maximum length strings
         if Error.Kind /= Required_Field_Missing then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Error constructor should preserve error kind"),
               Details     => Null_Unbounded_String,
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_Error_Constructor_Length_Limits")
            ));
         end if;
      end;

      return Void_Result.Ok (True);
   end Test_Error_Constructor_Length_Limits;

   function Test_Error_Factory_Length_Limits return Void_Result.Result is
   begin
--  Test factory creation with maximum length parameters
      declare
         Max_Context : constant String (1 .. Max_Error_Context_Length) := (others => 'X');
         Max_Correlation : constant String (1 .. Max_Correlation_ID_Length) := (others => 'Y');

         Factory : constant Error_Factory := Create_Factory (
            Default_Context => Max_Context,
            Correlation_ID  => Max_Correlation
         );

         Max_Field : constant String (1 .. Max_Field_Name_Length) := (others => 'Z');
         Max_Message : constant String (1 .. Max_Error_Message_Length) := (others => 'W');

         Error : constant Validation_Error_Type := Factory.Validation_Error (
            Kind          => Invalid_Format,
            Field_Name    => Max_Field,
            Invalid_Value => Max_Message,
            Message       => Max_Message
         );
      begin
--  If we reach here, factory contracts allowed maximum length strings
         if Error.Kind /= Invalid_Format then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Factory should preserve error kind"),
               Details     => Null_Unbounded_String,
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_Error_Factory_Length_Limits")
            ));
         end if;
      end;

      return Void_Result.Ok (True);
   end Test_Error_Factory_Length_Limits;

   function Test_Error_Constructor_Boundary_Conditions return Void_Result.Result is
   begin
--  Test with minimal required parameters
      declare
         Error : constant Validation_Error_Type := Make_Validation_Error (
            Kind       => Required_Field_Missing,
            Field_Name => "test"
         );
      begin
         if Error.Kind /= Required_Field_Missing then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Error constructor should handle minimal parameters"),
               Details     => Null_Unbounded_String,
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_Error_Constructor_Boundary_Conditions")
            ));
         end if;
      end;

--  Test business rule error minimal parameters
      declare
         Error : constant Business_Rule_Error_Type := Make_Business_Rule_Error (
            Kind      => Invariant_Violated,
            Rule_Name => "test_rule"
         );
      begin
         if Error.Kind /= Invariant_Violated then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Business rule error should preserve kind"),
               Details     => Null_Unbounded_String,
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_Error_Constructor_Boundary_Conditions")
            ));
         end if;
      end;

      return Void_Result.Ok (True);
   end Test_Error_Constructor_Boundary_Conditions;

--   ==========================================================================
--   Repository and Aggregate Tests (Placeholder for now)
--   ==========================================================================

   function Test_Repository_Transaction_State_Contracts return Void_Result.Result is
   begin
--  Note: Repository contracts are interface-level and would need concrete implementations to test
--  This is a placeholder that validates the test framework works
      return Void_Result.Ok (True);
   end Test_Repository_Transaction_State_Contracts;

   function Test_Repository_Save_Contracts return Void_Result.Result is
   begin
--  Note: Repository contracts are interface-level and would need concrete implementations to test
      return Void_Result.Ok (True);
   end Test_Repository_Save_Contracts;

   function Test_Repository_Batch_Operation_Contracts return Void_Result.Result is
   begin
--  Note: Repository contracts are interface-level and would need concrete implementations to test
      return Void_Result.Ok (True);
   end Test_Repository_Batch_Operation_Contracts;

   function Test_Aggregate_State_Management_Contracts return Void_Result.Result is
   begin
--  Note: Aggregate contracts are generic and would need concrete instantiations to test
      return Void_Result.Ok (True);
   end Test_Aggregate_State_Management_Contracts;

   function Test_Aggregate_Event_History_Contracts return Void_Result.Result is
   begin
--  Note: Aggregate contracts are generic and would need concrete instantiations to test
      return Void_Result.Ok (True);
   end Test_Aggregate_Event_History_Contracts;

   function Test_Aggregate_Change_Tracking_Contracts return Void_Result.Result is
   begin
--  Note: Aggregate contracts are generic and would need concrete instantiations to test
      return Void_Result.Ok (True);
   end Test_Aggregate_Change_Tracking_Contracts;

--   ==========================================================================
--   Main Test Runner
--   ==========================================================================

   function Run_All_Tests
     (Output : access Test_Output_Port'Class) return Test_Stats_Result.Result
   is
      Tests : Test_Results_Array (1 .. 9);
      Index : Positive := 1;

      procedure Add_Test_Result (Name : String; Test : access function return Void_Result.Result) is
         Result : constant Void_Result.Result := Test.all;
      begin
         if Result.Is_Ok then
            Tests (Index) := (
               Name           => To_Unbounded_String (Name),
               Status         => Passed,
               Message        => Null_Unbounded_String,
               Elapsed_Time   => 0.0,
               Line_Number    => 0,
               Correlation_ID => To_Unbounded_String ("CONTRACT-" & Name)
            );
            Print_Test_Result (Tests (Index), Output);
            Index := Index + 1;
         else
            declare
               Error : constant Test_Error := Result.Get_Err;
            begin
               Tests (Index) := (
                  Name           => To_Unbounded_String (Name),
                  Status         => Failed,
                  Message        => Error.Message,
                  Elapsed_Time   => 0.0,
                  Line_Number    => Error.Line_Number,
                  Correlation_ID => To_Unbounded_String ("CONTRACT-" & Name)
               );
               Print_Test_Result (Tests (Index), Output);
               Index := Index + 1;
            end;
         end if;
      end Add_Test_Result;

   begin
      Output.Write_Line ("=== Running Contract Validation Tests ===");
      Output.Write_Line ("");

--  File Path Contract Tests (temporarily disabled due to Type_Invariant interactions)
--  Add_Test_Result ("Test_File_Path_Creation_Contracts", Test_File_Path_Creation_Contracts'Access);
--  Add_Test_Result ("Test_File_Path_Validation_Contracts", Test_File_Path_Validation_Contracts'Access);
--  Add_Test_Result ("Test_File_Path_Manipulation_Contracts", Test_File_Path_Manipulation_Contracts'Access);

--  ULID Contract Tests
      Add_Test_Result ("Test_ULID_String_Validation_Contracts",
                      Test_ULID_String_Validation_Contracts'Access);
      Add_Test_Result ("Test_ULID_Generation_Contracts", Test_ULID_Generation_Contracts'Access);
      Add_Test_Result ("Test_ULID_Protected_Generator_Contracts",
                      Test_ULID_Protected_Generator_Contracts'Access);

--  Error Construction Contract Tests
      Add_Test_Result ("Test_Error_Constructor_Length_Limits", Test_Error_Constructor_Length_Limits'Access);
      Add_Test_Result ("Test_Error_Factory_Length_Limits", Test_Error_Factory_Length_Limits'Access);
      Add_Test_Result ("Test_Error_Constructor_Boundary_Conditions", Test_Error_Constructor_Boundary_Conditions'Access);

--  Repository and Aggregate Contract Tests (placeholders)
      Add_Test_Result ("Test_Repository_Transaction_State_Contracts",
                      Test_Repository_Transaction_State_Contracts'Access);
      Add_Test_Result ("Test_Repository_Save_Contracts", Test_Repository_Save_Contracts'Access);
      Add_Test_Result ("Test_Repository_Batch_Operation_Contracts",
                      Test_Repository_Batch_Operation_Contracts'Access);

--  Generate summary
      declare
         Stats_Result : constant Test_Stats_Result.Result :=
            Run_Test_Suite ("Contract_Validation_Tests", Tests (1 .. Index - 1), Output);
      begin
         if Stats_Result.Is_Ok then
            declare
               Stats : constant Test_Statistics := Stats_Result.Get_Ok;
            begin
               Output.Write_Line ("");
               Print_Test_Summary ("Contract Validation Tests", Stats, Output);
               return Test_Stats_Result.Ok (Stats);
            end;
         else
            return Stats_Result;
         end if;
      end;
   end Run_All_Tests;

end Test_Contracts;
