--   =============================================================================
--   Test_ULID_Helpers - ULID Helpers Unit Tests
--   =============================================================================
--   Copyright (c) 2025 A Bit of Help, Inc.
--   SPDX-License-Identifier: MIT
--
--   Purpose:
--     Unit tests for ULID helper utilities that provide safe ULID operations
--     including generation, validation, and timestamp extraction.
--   =============================================================================

pragma Ada_2022;

with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;
with Ada.Calendar; use Ada.Calendar;
with ULID; use ULID;
with Abohlib.Core.Domain.Utilities.ULID_Helpers;
--  Already withed in specification

package body Test_ULID_Helpers is

--  use Abohlib.Infrastructure.Testing.Test_Framework; -- Already use-visible from spec
   use Abohlib.Core.Domain.Utilities.ULID_Helpers;

--   ==========================================================================
--   Test Functions
--   ==========================================================================

   function Test_Constants return Void_Result.Result is
   begin
--  Test ULID constants
      pragma Warnings (Off, "condition is always False");
      if Null_ULID /= 0 then
      pragma Warnings (On, "condition is always False");
         return Void_Result.Err (Test_Error'(
            Kind        => Assertion_Failed,
            Message     => To_Unbounded_String ("Null_ULID should be 0"),
            Details     => To_Unbounded_String ("Got: " & Null_ULID'Image),
            Line_Number => 0,
            Test_Name   => To_Unbounded_String ("Test_Constants")
         ));
      end if;

      pragma Warnings (Off, "condition is always False");
      if ULID_String_Length /= 26 then
      pragma Warnings (On, "condition is always False");
         return Void_Result.Err (Test_Error'(
            Kind        => Assertion_Failed,
            Message     => To_Unbounded_String ("ULID_String_Length should be 26"),
            Details     => To_Unbounded_String ("Got: " & ULID_String_Length'Image),
            Line_Number => 0,
            Test_Name   => To_Unbounded_String ("Test_Constants")
         ));
      end if;

      return Void_Result.Ok (True);
   end Test_Constants;

   function Test_Is_Null_ULID return Void_Result.Result is
   begin
--  Test null ULID
      if not Is_Null (Null_ULID) then
         return Void_Result.Err (Test_Error'(
            Kind        => Assertion_Failed,
            Message     => To_Unbounded_String ("Null_ULID should be detected as null"),
            Details     => Null_Unbounded_String,
            Line_Number => 0,
            Test_Name   => To_Unbounded_String ("Test_Is_Null_ULID")
         ));
      end if;

--  Test zero ULID
      if not Is_Null (0) then
         return Void_Result.Err (Test_Error'(
            Kind        => Assertion_Failed,
            Message     => To_Unbounded_String ("Zero should be detected as null ULID"),
            Details     => Null_Unbounded_String,
            Line_Number => 0,
            Test_Name   => To_Unbounded_String ("Test_Is_Null_ULID")
         ));
      end if;

--  Test non-null ULID
      declare
         Non_Null : constant ULID.ULID_Number := New_ULID;
      begin
         if Is_Null (Non_Null) then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Generated ULID should not be null"),
               Details     => To_Unbounded_String ("ULID: " & Non_Null'Image),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_Is_Null_ULID")
            ));
         end if;
      end;

      return Void_Result.Ok (True);
   end Test_Is_Null_ULID;

   function Test_ULID_Generation return Void_Result.Result is
   begin
--  Test ULID generation
      declare
         ULID1 : constant ULID.ULID_Number := New_ULID;
         ULID2 : constant ULID.ULID_Number := New_ULID;
      begin
--  ULIDs should not be null
         if Is_Null (ULID1) or Is_Null (ULID2) then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Generated ULIDs should not be null"),
               Details     => To_Unbounded_String ("ULID1: " & ULID1'Image & ", ULID2: " & ULID2'Image),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_ULID_Generation")
            ));
         end if;

--  ULIDs should be different (extremely unlikely to be same)
         if ULID1 = ULID2 then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Generated ULIDs should be different"),
               Details     => To_Unbounded_String ("Both ULIDs: " & ULID1'Image),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_ULID_Generation")
            ));
         end if;
      end;

      return Void_Result.Ok (True);
   end Test_ULID_Generation;

   function Test_ULID_String_Generation return Void_Result.Result is
   begin
--  Test ULID string generation
      declare
         ULID_Str1 : constant String := New_ULID_String;
         ULID_Str2 : constant String := New_ULID_String;
      begin
--  Check string length
         if ULID_Str1'Length /= ULID_String_Length then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("ULID string should be 26 characters"),
               Details     => To_Unbounded_String ("Length: " & ULID_Str1'Length'Image & ", String: " & ULID_Str1),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_ULID_String_Generation")
            ));
         end if;

         if ULID_Str2'Length /= ULID_String_Length then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Second ULID string should be 26 characters"),
               Details     => To_Unbounded_String ("Length: " & ULID_Str2'Length'Image & ", String: " & ULID_Str2),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_ULID_String_Generation")
            ));
         end if;

--  Strings should be different
         if ULID_Str1 = ULID_Str2 then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Generated ULID strings should be different"),
               Details     => To_Unbounded_String ("Both strings: " & ULID_Str1),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_ULID_String_Generation")
            ));
         end if;

--  Test if strings are valid ULID format
         if not Is_Valid_ULID_String (ULID_Str1) then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Generated ULID string should be valid"),
               Details     => To_Unbounded_String ("String: " & ULID_Str1),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_ULID_String_Generation")
            ));
         end if;

         if not Is_Valid_ULID_String (ULID_Str2) then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Second generated ULID string should be valid"),
               Details     => To_Unbounded_String ("String: " & ULID_Str2),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_ULID_String_Generation")
            ));
         end if;
      end;

      return Void_Result.Ok (True);
   end Test_ULID_String_Generation;

   function Test_ULID_String_Validation return Void_Result.Result is
   begin
--  Test valid ULID strings
      declare
         Valid_ULID : constant String := New_ULID_String;
      begin
         if not Is_Valid_ULID_String (Valid_ULID) then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Generated ULID should be valid"),
               Details     => To_Unbounded_String ("ULID: " & Valid_ULID),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_ULID_String_Validation")
            ));
         end if;
      end;

--  Test invalid ULID strings
      if Is_Valid_ULID_String ("") then
         return Void_Result.Err (Test_Error'(
            Kind        => Assertion_Failed,
            Message     => To_Unbounded_String ("Empty string should not be valid ULID"),
            Details     => Null_Unbounded_String,
            Line_Number => 0,
            Test_Name   => To_Unbounded_String ("Test_ULID_String_Validation")
         ));
      end if;

      if Is_Valid_ULID_String ("short") then
         return Void_Result.Err (Test_Error'(
            Kind        => Assertion_Failed,
            Message     => To_Unbounded_String ("Short string should not be valid ULID"),
            Details     => Null_Unbounded_String,
            Line_Number => 0,
            Test_Name   => To_Unbounded_String ("Test_ULID_String_Validation")
         ));
      end if;

      if Is_Valid_ULID_String ("0123456789012345678901234") then
         return Void_Result.Err (Test_Error'(
            Kind        => Assertion_Failed,
            Message     => To_Unbounded_String ("25-char string should not be valid ULID"),
            Details     => Null_Unbounded_String,
            Line_Number => 0,
            Test_Name   => To_Unbounded_String ("Test_ULID_String_Validation")
         ));
      end if;

      if Is_Valid_ULID_String ("012345678901234567890123456") then
         return Void_Result.Err (Test_Error'(
            Kind        => Assertion_Failed,
            Message     => To_Unbounded_String ("27-char string should not be valid ULID"),
            Details     => Null_Unbounded_String,
            Line_Number => 0,
            Test_Name   => To_Unbounded_String ("Test_ULID_String_Validation")
         ));
      end if;

--  Test with invalid characters
      if Is_Valid_ULID_String ("01234567890123456789012345!") then
         return Void_Result.Err (Test_Error'(
            Kind        => Assertion_Failed,
            Message     => To_Unbounded_String ("String with invalid chars should not be valid ULID"),
            Details     => Null_Unbounded_String,
            Line_Number => 0,
            Test_Name   => To_Unbounded_String ("Test_ULID_String_Validation")
         ));
      end if;

      return Void_Result.Ok (True);
   end Test_ULID_String_Validation;

   function Test_Timestamp_Extraction return Void_Result.Result is
   begin
--  Test timestamp extraction from generated ULID
      declare
         Start_Time : constant Ada.Calendar.Time := Ada.Calendar.Clock;
         Test_ULID  : constant ULID.ULID_Number := New_ULID;
         End_Time   : constant Ada.Calendar.Time := Ada.Calendar.Clock;
         Extracted  : constant Ada.Calendar.Time := Extract_Timestamp (Test_ULID);
         Time_Tolerance : constant Duration := 1.0; -- Allow 1 second tolerance
      begin
--  Note: Current implementation returns Clock for non-null ULIDs, so we allow some tolerance
--  Extracted timestamp should be reasonably close to generation time
         if Extracted < (Start_Time - Time_Tolerance) or Extracted > (End_Time + Time_Tolerance) then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Extracted timestamp should be within reasonable tolerance"),
               Details     => To_Unbounded_String ("Start: " & Ada.Calendar.Time'Image (Start_Time) &
                                                  ", End: " & Ada.Calendar.Time'Image (End_Time) &
                                                  ", Extracted: " & Ada.Calendar.Time'Image (Extracted)),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_Timestamp_Extraction")
            ));
         end if;
      end;

--  Test null ULID timestamp (should return Unix epoch)
      declare
         Null_Timestamp : constant Ada.Calendar.Time := Extract_Timestamp (Null_ULID);
         Unix_Epoch : constant Ada.Calendar.Time := Ada.Calendar.Time_Of (1970, 1, 1, 0.0);
         Time_Diff : constant Duration := abs (Null_Timestamp - Unix_Epoch);
      begin
--  Null ULID should extract to Unix epoch
         if Time_Diff > 1.0 then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Null ULID should extract to Unix epoch"),
               Details     => To_Unbounded_String ("Expected: " & Ada.Calendar.Time'Image (Unix_Epoch) &
                                                  ", Got: " & Ada.Calendar.Time'Image (Null_Timestamp)),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_Timestamp_Extraction")
            ));
         end if;
      end;

      return Void_Result.Ok (True);
   end Test_Timestamp_Extraction;

   function Test_Age_Calculation return Void_Result.Result is
   begin
--  Test age calculation for newly generated ULID
      declare
         Test_ULID : constant ULID.ULID_Number := New_ULID;
         Age       : constant Duration := Get_Age (Test_ULID);
      begin
--  Age should be very small for newly generated ULID
         if Age < 0.0 then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Age should not be negative"),
               Details     => To_Unbounded_String ("Age: " & Age'Image),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_Age_Calculation")
            ));
         end if;

--  Age should be very small (less than 1 second for a newly generated ULID)
         if Age > 1.0 then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Age should be very small for new ULID"),
               Details     => To_Unbounded_String ("Age: " & Age'Image),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_Age_Calculation")
            ));
         end if;
      end;

--  Test age of null ULID (should be very large)
      declare
         Null_Age : constant Duration := Get_Age (Null_ULID);
      begin
--  Null ULID age should be very large (years)
         if Null_Age < 365.0 * 24.0 * 3600.0 then -- Less than 1 year
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Null ULID age should be very large"),
               Details     => To_Unbounded_String ("Age: " & Null_Age'Image),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_Age_Calculation")
            ));
         end if;
      end;

      return Void_Result.Ok (True);
   end Test_Age_Calculation;

   function Test_Safe_Operations return Void_Result.Result is
   begin
--  Test safe ULID generation
      declare
         Result : constant ULID_Result.Result := New_ULID_Safe;
      begin
         if not Result.Is_Ok then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Safe ULID generation should succeed"),
               Details     => To_Unbounded_String ("Error: " & To_String (Result.Get_Err)),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_Safe_Operations")
            ));
         end if;

         declare
            Generated : constant ULID.ULID_Number := Result.Get_Ok;
         begin
            if Is_Null (Generated) then
               return Void_Result.Err (Test_Error'(
                  Kind        => Assertion_Failed,
                  Message     => To_Unbounded_String ("Safe generated ULID should not be null"),
                  Details     => To_Unbounded_String ("ULID: " & Generated'Image),
                  Line_Number => 0,
                  Test_Name   => To_Unbounded_String ("Test_Safe_Operations")
               ));
            end if;
         end;
      end;

--  Test safe timestamp extraction
      declare
         Test_ULID : constant ULID.ULID_Number := New_ULID;
         Result : constant Time_Result.Result := Extract_Timestamp_Safe (Test_ULID);
      begin
         if not Result.Is_Ok then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Safe timestamp extraction should succeed"),
               Details     => To_Unbounded_String ("Error: " & To_String (Result.Get_Err)),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_Safe_Operations")
            ));
         end if;

--  Timestamp should be recent
         declare
            Now : constant Ada.Calendar.Time := Ada.Calendar.Clock;
            Extracted : constant Ada.Calendar.Time := Result.Get_Ok;
            Time_Diff : constant Duration := abs (Now - Extracted);
         begin
            if Time_Diff > 1.0 then
               return Void_Result.Err (Test_Error'(
                  Kind        => Assertion_Failed,
                  Message     => To_Unbounded_String ("Extracted timestamp should be recent"),
                  Details     => To_Unbounded_String ("Now: " & Ada.Calendar.Time'Image (Now) &
                                                     ", Extracted: " & Ada.Calendar.Time'Image (Extracted)),
                  Line_Number => 0,
                  Test_Name   => To_Unbounded_String ("Test_Safe_Operations")
               ));
            end if;
         end;
      end;

--  Test safe age calculation
      declare
         Test_ULID : constant ULID.ULID_Number := New_ULID;
         Result : constant Duration_Result.Result := Get_Age_Safe (Test_ULID);
      begin
         if not Result.Is_Ok then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Safe age calculation should succeed"),
               Details     => To_Unbounded_String ("Error: " & To_String (Result.Get_Err)),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_Safe_Operations")
            ));
         end if;

         declare
            Age : constant Duration := Result.Get_Ok;
         begin
            if Age < 0.0 or Age > 1.0 then
               return Void_Result.Err (Test_Error'(
                  Kind        => Assertion_Failed,
                  Message     => To_Unbounded_String ("Safe age should be small and positive"),
                  Details     => To_Unbounded_String ("Age: " & Age'Image),
                  Line_Number => 0,
                  Test_Name   => To_Unbounded_String ("Test_Safe_Operations")
               ));
            end if;
         end;
      end;

--  Test safe string validation
      declare
         Valid_String : constant String := New_ULID_String;
         Result : constant Boolean_Result.Result := Is_Valid_ULID_String_Safe (Valid_String);
      begin
         if not Result.Is_Ok then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Safe string validation should succeed"),
               Details     => To_Unbounded_String ("Error: " & To_String (Result.Get_Err)),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_Safe_Operations")
            ));
         end if;

         if not Result.Get_Ok then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Generated string should be valid"),
               Details     => To_Unbounded_String ("String: " & Valid_String),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_Safe_Operations")
            ));
         end if;
      end;

      return Void_Result.Ok (True);
   end Test_Safe_Operations;

   function Test_Generator_Reset return Void_Result.Result is
   begin
--  Test generator reset
      ULID_Generator.Reset;

--  Generate ULIDs after reset
      declare
         ULID1 : constant ULID.ULID_Number := New_ULID;
         ULID2 : constant ULID.ULID_Number := New_ULID;
      begin
--  Should still generate valid, unique ULIDs
         if Is_Null (ULID1) or Is_Null (ULID2) then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("ULIDs after reset should not be null"),
               Details     => To_Unbounded_String ("ULID1: " & ULID1'Image & ", ULID2: " & ULID2'Image),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_Generator_Reset")
            ));
         end if;

         if ULID1 = ULID2 then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("ULIDs after reset should be unique"),
               Details     => To_Unbounded_String ("Both ULIDs: " & ULID1'Image),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_Generator_Reset")
            ));
         end if;
      end;

--  Test generator reset with seed
      ULID_Generator.Reset (12345);

      declare
         ULID3 : constant ULID.ULID_Number := New_ULID;
      begin
         if Is_Null (ULID3) then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("ULID after seeded reset should not be null"),
               Details     => To_Unbounded_String ("ULID: " & ULID3'Image),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_Generator_Reset")
            ));
         end if;
      end;

      return Void_Result.Ok (True);
   end Test_Generator_Reset;

   pragma Warnings (Off, "function ""Test_Protected_Generator"" is not referenced");
   function Test_Protected_Generator return Void_Result.Result is
   pragma Warnings (On, "function ""Test_Protected_Generator"" is not referenced");
   begin
--  Test protected generator procedures
      declare
         Generated_ULID : ULID.ULID_Number;
         Generated_String : String (1 .. ULID_String_Length);
         Last : Natural;
      begin
--  Test protected Generate procedure
         ULID_Generator.Generate (Generated_ULID);

         if Is_Null (Generated_ULID) then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Protected generator should produce non-null ULID"),
               Details     => To_Unbounded_String ("ULID: " & Generated_ULID'Image),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_Protected_Generator")
            ));
         end if;

--  Test protected Generate_String procedure
         ULID_Generator.Generate_String (Generated_String, Last);

         if Last /= ULID_String_Length then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Protected string generator should produce full-length string"),
               Details     => To_Unbounded_String ("Expected: " & ULID_String_Length'Image &
                                                  ", Got: " & Last'Image),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_Protected_Generator")
            ));
         end if;

         if not Is_Valid_ULID_String (Generated_String) then
            return Void_Result.Err (Test_Error'(
               Kind        => Assertion_Failed,
               Message     => To_Unbounded_String ("Protected generator should produce valid ULID string"),
               Details     => To_Unbounded_String ("String: " & Generated_String),
               Line_Number => 0,
               Test_Name   => To_Unbounded_String ("Test_Protected_Generator")
            ));
         end if;
      end;

      return Void_Result.Ok (True);
   end Test_Protected_Generator;

--   ==========================================================================
--   Run All Tests
--   ==========================================================================

   function Run_All_Tests
     (Output : access Test_Output_Port'Class) return Test_Stats_Result.Result
   is
      Tests : Test_Results_Array (1 .. 9);
      Index : Positive := 1;

      procedure Add_Test_Result
        (Name : String;
         Test_Func : Test_Function_Access)
      is
         Result : constant Test_Result_Pkg.Result :=
            Run_Test (Name, Test_Func, Output);
      begin
         if Result.Is_Ok then
            Tests (Index) := Result.Get_Ok;
            Print_Test_Result (Tests (Index), Output);
            Index := Index + 1;
         else
--  Handle test execution error
            declare
               Error : constant Test_Error := Result.Get_Err;
            begin
               Tests (Index) := Test_Result'(
                  Name           => To_Unbounded_String (Name),
                  Status         => Failed,
                  Message        => Error.Message,
                  Elapsed_Time   => 0.0,
                  Line_Number    => Error.Line_Number,
                  Correlation_ID => To_Unbounded_String ("TEST-" & Name)
               );
               Print_Test_Result (Tests (Index), Output);
               Index := Index + 1;
            end;
         end if;
      end Add_Test_Result;

   begin
      Output.Write_Line ("=== Running ULID Helpers Unit Tests ===");
      Output.Write_Line ("");

--  Run all tests
      Add_Test_Result ("Test_Constants", Test_Constants'Access);
      Add_Test_Result ("Test_Is_Null_ULID", Test_Is_Null_ULID'Access);
      Add_Test_Result ("Test_ULID_Generation", Test_ULID_Generation'Access);
      Add_Test_Result ("Test_ULID_String_Generation", Test_ULID_String_Generation'Access);
      Add_Test_Result ("Test_ULID_String_Validation", Test_ULID_String_Validation'Access);
      Add_Test_Result ("Test_Timestamp_Extraction", Test_Timestamp_Extraction'Access);
      Add_Test_Result ("Test_Age_Calculation", Test_Age_Calculation'Access);
      Add_Test_Result ("Test_Safe_Operations", Test_Safe_Operations'Access);
      Add_Test_Result ("Test_Generator_Reset", Test_Generator_Reset'Access);

--  Note: Protected generator test might need special handling in some environments
--  Add_Test_Result ("Test_Protected_Generator", Test_Protected_Generator'Access);

--  Generate summary
      declare
         Stats_Result : constant Test_Stats_Result.Result :=
            Run_Test_Suite ("ULID_Helpers_Tests", Tests (1 .. Index - 1), Output);
      begin
         if Stats_Result.Is_Ok then
            declare
               Stats : constant Test_Statistics := Stats_Result.Get_Ok;
            begin
               Output.Write_Line ("");
               Print_Test_Summary ("ULID Helpers Unit Tests", Stats, Output);
               return Test_Stats_Result.Ok (Stats);
            end;
         else
            return Stats_Result;
         end if;
      end;
   end Run_All_Tests;

end Test_ULID_Helpers;
